fn main(){
    let x = String::from("gray");
    let y = "cassible".to_string();
    let result = longest(&x, &y);
    println!("The longest string is {}", result);
}
/**
 * 一个变量在创建时生命周期随之开始，销毁时生命周期也随之结束。
 * 在存在多个引用时，编译器有时会无法自动推导生命周期，无法得知返回的是哪个引用。
 * 和泛型一样，使用生命周期参数，需要先声明<'a>
 * x,y和返回值 活的要和‘a一样久（因为要么返回值是 x, 要么返回值是 y）
 * 个人理解：我需要用到的参数，需要和我活的一样久（or 更久），不然我怕我用到一半，参数没了？
 * 放到代码里：我出在 生命周期中间
 * 创建我要用到的东西： --- 东西进入
 * 创建我：           --- 我进入
 * 我使用东西：        --- 使用，东西结束，我结束
 * ----------------------------------------------------------
 * 东西存活的时间比我更短，编译器觉得会有风险（用到一半，东西没了），编译器会拒绝编译，如何处理？
 * 通过生命周期，告诉编译器东西其实活的和我一样久。编译器才会去编译，把生命周期理解为通过注释告诉编译器的一些规则，并不会实际改变任何代码运行结果
 * 创建我：             --- 我进入
 * 创建我用到的东西：     --- 东西进入
 * 我使用东西：          --- 东西结束，我结束
 * ----------------------------------------------------------
 * 函数的返回值如果是一个引用类型，那么它的生命周期只会来源于：函数参数的生命周期
 * 函数体中某个新创建的引用的生命周期，会被限制在函数体内，不会长久存在，就是典型的“悬垂引用”场景。随着函数体的销毁而销毁
 * 这也解释了为什么有时候不需要我们显式标注生命周期，因为这两种情况中，第二种是必定不编译的，那么编译器就只需要检查第一种情况，在只有一个引用参数情况下。编译器自然能看出来。
 * 函数 或  方法中，参数的生命周期被称为 “输入生命周期”，返回值的生命周期被称为 “输出生命周期“
 * -----------------------------------------------------------
 * Rust 默认的生命周期消除规则：
 * 1. 每个引用参数都有一个生命周期，由函数参数的生命周期决定。
 * 2. 若只有一个输入生命周期（函数参数中只有一个引用类型）， 那么该生命周期会被赋给所有输出生命周期，也就是所有返回值的生命周期都等于该输入生命周期。
 * 3. 若有多个输入生命周期，且其中一个是 &self 或 &mut self, 则 &self 的生命周期被赋给所有的”输出生命周期”，拥有 &self 形式的参数，说明该函数是一个 方法，改规则让方法的使用便利度大幅提升。
 * 生命周期约束：'a:'b --- 表示 ’a 的生命周期大于等于 'b
 * -----------------------------------------------------------
 * 静态生命周期：'static，拥有该生命周期的引用可以和整个程序活的一样久。
 * 生命周期 'static 意味着能和程序活的一样久，例如字符串字面量和特征对象。
 * 如果遇到解决不了的生命周期标注问题。可以尝试 T:‘static,有时候他会给你奇迹
 */
#[warn(unused_parens)]
 fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}